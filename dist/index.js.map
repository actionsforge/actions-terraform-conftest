{"version":3,"sources":["../src/index.ts","../src/setup-conftest.ts","../src/terraform.ts","../src/conftest.ts"],"sourcesContent":["import * as core from '@actions/core';\nimport * as path from 'path';\nimport { setupConftest } from './setup-conftest';\nimport { runTerraform } from './terraform';\nimport { runConftest } from './conftest';\n\nasync function run(): Promise<void> {\n  try {\n    // Get inputs\n    const conftestVersion = core.getInput('conftest-version') || 'latest';\n    const policyPath = core.getInput('policy-path') || './policy';\n    const workingDirectory = core.getInput('working-directory') || '.';\n    const runTerraformTest = core.getBooleanInput('run-terraform-test');\n    const runTerraformPlan = core.getBooleanInput('run-terraform-plan');\n    const runConftestValidation = core.getBooleanInput('run-conftest');\n    const terraformPlanFile = core.getInput('terraform-plan-file') || 'tfplan.json';\n\n    core.info('Starting Terraform Conftest Action');\n    core.info(`Conftest version: ${conftestVersion}`);\n    core.info(`Policy path: ${policyPath}`);\n    core.info(`Working directory: ${workingDirectory}`);\n    core.info(`Run terraform test: ${runTerraformTest}`);\n    core.info(`Run terraform plan: ${runTerraformPlan}`);\n    core.info(`Run conftest: ${runConftestValidation}`);\n\n    // Setup conftest\n    core.info('Setting up conftest...');\n    const conftestPath = await setupConftest(conftestVersion);\n    core.addPath(path.dirname(conftestPath));\n    core.info(`Conftest available at: ${conftestPath}`);\n\n    // Run terraform operations\n    let planFilePath: string | null = null;\n    if (runTerraformTest || runTerraformPlan) {\n      planFilePath = await runTerraform(\n        workingDirectory,\n        runTerraformTest,\n        runTerraformPlan,\n        terraformPlanFile\n      );\n    }\n\n    // Run conftest validation\n    let conftestPassed = true;\n    let violationsCount = 0;\n\n    if (runConftestValidation) {\n      if (!planFilePath) {\n        throw new Error(\n          'Cannot run conftest: terraform plan was not executed. Set run-terraform-plan to true.'\n        );\n      }\n\n      const result = await runConftest(conftestPath, planFilePath, policyPath);\n      conftestPassed = result.passed;\n      violationsCount = result.violationsCount;\n\n      if (!conftestPassed) {\n        core.setFailed(`Conftest validation failed with ${violationsCount} violation(s)`);\n      }\n    }\n\n    // Set outputs\n    if (planFilePath) {\n      core.setOutput('plan-file', planFilePath);\n    }\n    core.setOutput('conftest-passed', conftestPassed);\n    core.setOutput('violations-count', violationsCount);\n\n    core.info('Terraform Conftest Action completed successfully');\n  } catch (error) {\n    if (error instanceof Error) {\n      core.setFailed(error.message);\n    } else {\n      core.setFailed(`Unknown error: ${error}`);\n    }\n  }\n}\n\nrun();\n","import * as core from '@actions/core';\nimport * as tc from '@actions/tool-cache';\nimport * as exec from '@actions/exec';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as https from 'https';\n\nconst CONFTEST_REPO = 'open-policy-agent/conftest';\nconst CONFTEST_BINARY_NAME = 'conftest';\n\n/**\n * Resolves the latest conftest version from GitHub API\n */\nasync function resolveLatestVersion(): Promise<string> {\n  return new Promise((resolve, reject) => {\n    try {\n      const options = {\n        hostname: 'api.github.com',\n        path: `/repos/${CONFTEST_REPO}/releases/latest`,\n        method: 'GET',\n        headers: {\n          'User-Agent': 'actions-terraform-conftest',\n          Accept: 'application/vnd.github.v3+json'\n        }\n      };\n\n      const req = https.request(options, (res) => {\n        let data = '';\n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n        res.on('end', () => {\n          try {\n            const release = JSON.parse(data);\n            const version = release.tag_name.startsWith('v')\n              ? release.tag_name.substring(1)\n              : release.tag_name;\n            core.info(`Resolved latest version: ${version}`);\n            resolve(version);\n          } catch (error) {\n            reject(new Error(`Failed to parse GitHub API response: ${error}`));\n          }\n        });\n      });\n\n      req.on('error', (error) => {\n        reject(new Error(`Failed to fetch latest version: ${error.message}`));\n      });\n\n      req.end();\n    } catch (error) {\n      reject(new Error(`Failed to resolve latest version: ${error}`));\n    }\n  });\n}\n\n/**\n * Normalizes version string (removes 'v' prefix if present)\n */\nfunction normalizeVersion(version: string): string {\n  return version.startsWith('v') ? version.substring(1) : version;\n}\n\n/**\n * Downloads and caches conftest binary\n */\nexport async function setupConftest(version: string): Promise<string> {\n  const normalizedVersion = normalizeVersion(version);\n  core.info(`Setting up conftest version: ${normalizedVersion}`);\n\n  // Resolve version if \"latest\"\n  let resolvedVersion = normalizedVersion;\n  if (normalizedVersion === 'latest') {\n    resolvedVersion = await resolveLatestVersion();\n  }\n\n  // Check cache first\n  const cachedPath = tc.find(CONFTEST_BINARY_NAME, resolvedVersion);\n  if (cachedPath) {\n    core.info(`Using cached conftest at: ${cachedPath}`);\n    const conftestPath = path.join(cachedPath, CONFTEST_BINARY_NAME);\n    if (fs.existsSync(conftestPath)) {\n      await exec.exec('chmod', ['+x', conftestPath]);\n      return conftestPath;\n    }\n  }\n\n  // Download binary\n  const downloadUrl = `https://github.com/${CONFTEST_REPO}/releases/download/v${resolvedVersion}/conftest_${resolvedVersion}_Linux_x86_64.tar.gz`;\n  core.info(`Downloading conftest from: ${downloadUrl}`);\n\n  const downloadPath = await tc.downloadTool(downloadUrl);\n  core.info(`Downloaded to: ${downloadPath}`);\n\n  // Extract tar.gz\n  const extractPath = await tc.extractTar(downloadPath);\n  core.info(`Extracted to: ${extractPath}`);\n\n  // Find the conftest binary in the extracted directory\n  // The binary might be directly in extractPath or in a subdirectory\n  let extractedBinary = path.join(extractPath, CONFTEST_BINARY_NAME);\n\n  if (!fs.existsSync(extractedBinary)) {\n    // Check subdirectories\n    const files = fs.readdirSync(extractPath, { withFileTypes: true });\n    for (const file of files) {\n      if (file.isDirectory()) {\n        const subdirPath = path.join(extractPath, file.name);\n        const binaryInSubdir = path.join(subdirPath, CONFTEST_BINARY_NAME);\n        if (fs.existsSync(binaryInSubdir)) {\n          extractedBinary = binaryInSubdir;\n          break;\n        }\n      } else if (file.name === CONFTEST_BINARY_NAME) {\n        extractedBinary = path.join(extractPath, file.name);\n        break;\n      }\n    }\n  }\n\n  if (!fs.existsSync(extractedBinary)) {\n    throw new Error(`Conftest binary not found in extracted archive at: ${extractPath}`);\n  }\n\n  await exec.exec('chmod', ['+x', extractedBinary]);\n\n  // Cache the directory containing the binary\n  const binaryDir = path.dirname(extractedBinary);\n  const cachedDir = await tc.cacheDir(binaryDir, CONFTEST_BINARY_NAME, resolvedVersion);\n  const cachedBinary = path.join(cachedDir, CONFTEST_BINARY_NAME);\n\n  core.info(`Cached conftest at: ${cachedBinary}`);\n  return cachedBinary;\n}\n","import * as core from '@actions/core';\nimport * as exec from '@actions/exec';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\n/**\n * Runs terraform init\n */\nexport async function terraformInit(workingDirectory: string): Promise<void> {\n  core.info('Running terraform init...');\n  await exec.exec('terraform', ['init'], {\n    cwd: workingDirectory\n  });\n}\n\n/**\n * Runs terraform test\n */\nexport async function terraformTest(workingDirectory: string): Promise<void> {\n  core.info('Running terraform test...');\n  await exec.exec('terraform', ['test'], {\n    cwd: workingDirectory\n  });\n}\n\n/**\n * Runs terraform plan and generates JSON output\n */\nexport async function terraformPlan(\n  workingDirectory: string,\n  planFile: string\n): Promise<string> {\n  core.info('Running terraform plan...');\n\n  const planBinary = path.join(workingDirectory, 'tfplan.binary');\n  const planJson = path.join(workingDirectory, planFile);\n\n  // Run terraform plan with binary output\n  await exec.exec('terraform', ['plan', '-out', planBinary], {\n    cwd: workingDirectory\n  });\n\n  // Convert binary plan to JSON\n  core.info(`Converting plan to JSON: ${planJson}`);\n  const jsonOutput: string[] = [];\n  const exitCode = await exec.exec('terraform', ['show', '-json', planBinary], {\n    cwd: workingDirectory,\n    listeners: {\n      stdout: (data: Buffer) => {\n        jsonOutput.push(data.toString());\n      }\n    },\n    silent: false\n  });\n\n  if (exitCode !== 0) {\n    throw new Error(`Failed to convert terraform plan to JSON. Exit code: ${exitCode}`);\n  }\n\n  // Write JSON to file\n  const jsonContent = jsonOutput.join('');\n  fs.writeFileSync(planJson, jsonContent);\n  core.info(`Plan JSON written to: ${planJson}`);\n\n  return planJson;\n}\n\n/**\n * Executes terraform operations based on configuration\n */\nexport async function runTerraform(\n  workingDirectory: string,\n  runTest: boolean,\n  runPlan: boolean,\n  planFile: string\n): Promise<string | null> {\n  // Ensure working directory exists\n  if (!fs.existsSync(workingDirectory)) {\n    throw new Error(`Working directory does not exist: ${workingDirectory}`);\n  }\n\n  // Run terraform init\n  await terraformInit(workingDirectory);\n\n  // Run terraform test if enabled\n  if (runTest) {\n    await terraformTest(workingDirectory);\n  }\n\n  // Run terraform plan if enabled\n  if (runPlan) {\n    return await terraformPlan(workingDirectory, planFile);\n  }\n\n  return null;\n}\n","import * as core from '@actions/core';\nimport * as exec from '@actions/exec';\nimport * as fs from 'fs';\n\n/**\n * Runs conftest validation on the plan JSON file\n */\nexport async function runConftest(\n  conftestPath: string,\n  planFile: string,\n  policyPath: string\n): Promise<{ passed: boolean; violationsCount: number }> {\n  core.info(`Running conftest test on: ${planFile}`);\n  core.info(`Using policy path: ${policyPath}`);\n\n  // Verify plan file exists\n  if (!fs.existsSync(planFile)) {\n    throw new Error(`Plan file does not exist: ${planFile}`);\n  }\n\n  // Verify policy path exists\n  if (!fs.existsSync(policyPath)) {\n    throw new Error(`Policy path does not exist: ${policyPath}`);\n  }\n\n  let exitCode = 0;\n  const output: string[] = [];\n  const errors: string[] = [];\n\n  try {\n    await exec.exec(conftestPath, ['test', planFile, '-p', policyPath], {\n      listeners: {\n        stdout: (data: Buffer) => {\n          output.push(data.toString());\n        },\n        stderr: (data: Buffer) => {\n          errors.push(data.toString());\n        }\n      },\n      ignoreReturnCode: true\n    });\n  } catch (error) {\n    // exec.exec throws if exit code is non-zero, but we're using ignoreReturnCode\n    // So we need to check the actual exit code\n    exitCode = typeof error === 'object' && error !== null && 'code' in error ? (error as { code: number }).code : 1;\n  }\n\n  const outputText = output.join('');\n  const errorText = errors.join('');\n\n  // Conftest returns exit code 1 if violations are found\n  const passed = exitCode === 0;\n  const violationsCount = passed ? 0 : parseViolationsCount(outputText + errorText);\n\n  if (!passed) {\n    core.warning(`Conftest found ${violationsCount} policy violation(s)`);\n    core.info('Conftest output:');\n    if (outputText) {\n      core.info(outputText);\n    }\n    if (errorText) {\n      core.error(errorText);\n    }\n  } else {\n    core.info('Conftest validation passed');\n    if (outputText) {\n      core.info(outputText);\n    }\n  }\n\n  return { passed, violationsCount };\n}\n\n/**\n * Parses the number of violations from conftest output\n */\nfunction parseViolationsCount(output: string): number {\n  // Conftest output typically shows violations like:\n  // \"FAIL - main.tf - <violation message>\"\n  // or lists them in a structured format\n  const failMatches = output.match(/FAIL/g);\n  if (failMatches) {\n    return failMatches.length;\n  }\n\n  // Try to match violation patterns\n  const violationPatterns = [\n    /(\\d+)\\s+violation/i,\n    /(\\d+)\\s+test.*fail/i,\n    /(\\d+)\\s+deny/i\n  ];\n\n  for (const pattern of violationPatterns) {\n    const match = output.match(pattern);\n    if (match) {\n      return parseInt(match[1], 10);\n    }\n  }\n\n  // If we can't parse, assume at least 1 violation if output contains \"FAIL\" or \"deny\"\n  if (output.toLowerCase().includes('fail') || output.toLowerCase().includes('deny')) {\n    return 1;\n  }\n\n  return 0;\n}\n"],"mappings":"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","names":["core","path","error","core","exec","path","fs","core","exec","fs","error","error"]}